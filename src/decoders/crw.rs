use decoders::*;
use decoders::ciff::*;
use decoders::basics::*;
use std::f32::NAN;
use itertools::Itertools;
use std::cmp;

#[derive(Debug, Clone)]
pub struct CrwDecoder<'a> {
  buffer: &'a [u8],
  rawloader: &'a RawLoader,
  ciff: CiffIFD<'a>,
}

impl<'a> CrwDecoder<'a> {
  pub fn new(buf: &'a [u8], ciff: CiffIFD<'a>, rawloader: &'a RawLoader) -> CrwDecoder<'a> {
    CrwDecoder {
      buffer: buf,
      ciff: ciff,
      rawloader: rawloader,
    }
  }
}

impl<'a> Decoder for CrwDecoder<'a> {
  fn image(&self) -> Result<Image,String> {
    let makemodel = fetch_tag!(self.ciff, CiffTag::MakeModel).get_strings();
    if makemodel.len() < 2 {
      return Err("CRW: MakeModel tag needs to have 2 strings".to_string())
    }
    let camera = try!(self.rawloader.check_supported_with_everything(&makemodel[0], &makemodel[1], ""));

    let sensorinfo = fetch_tag!(self.ciff, CiffTag::SensorInfo);
    let width = sensorinfo.get_u32(1);
    let height = sensorinfo.get_u32(2);

    let image = try!(self.decode_compressed(camera, width as usize, height as usize));

    ok_image(camera, width, height, try!(self.get_wb()), image)
  }
}

impl<'a> CrwDecoder<'a> {
  fn get_wb(&self) -> Result<[f32;4], String> {
    Ok([NAN,NAN,NAN,NAN])
  }

  // The rest of this file was ported from dcraw. The code seems different enough that
  // it doesn't make sense to try and share the huffman stuff with the normal ljpeg code

  /*
     Construct a decode tree according the specification in *source.
     The first 16 bytes specify how many codes should be 1-bit, 2-bit
     3-bit, etc.  Bytes after that are the leaf values.

     For example, if the source is

      { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
        0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },

     then the code is

          00                0x04
          010               0x03
          011               0x05
          100               0x06
          101               0x02
          1100              0x07
          1101              0x01
          11100             0x08
          11101             0x09
          11110             0x00
          111110            0x0a
          1111110           0x0b
          1111111           0xff
   */

  fn make_decoder(source: &[u8]) -> Vec<u16> {
    let mut max: usize = 16;
    for i in 0..16 {
      if source[15-i] != 0 {
        break;
      }
      max -= 1;
    }

    let mut tbl = vec![0 as u16; (1 << max) + 1];
    tbl[0] = max as u16;
    let mut h = 1;
    let mut pos = 16;
    for len in 1..(max+1) {
      for _ in 0..source[len-1] {
        for _ in 0..(1 << (max-len)) {
          if h <= (1 << max) {
            tbl[h] = (len as u16) << 8 | (source[pos] as u16);
            h += 1;
          }
        }
        pos += 1;
      }
    }
    tbl
  }

  pub fn init_huff_tables(num: usize) -> [Vec<u16>;2] {
    let first_tree: [[u8;29];3] = [
      [ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
        0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff ],
      [ 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,
        0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff ],
      [ 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,
        0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff ],
    ];

    let second_tree: [[u8;180];3] = [
      [ 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,
        0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,
        0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,
        0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,
        0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,
        0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,
        0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,
        0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,
        0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,
        0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,
        0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,
        0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,
        0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,
        0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,
        0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff ],
      [ 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,
        0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,
        0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,
        0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,
        0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,
        0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,
        0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,
        0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,
        0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,
        0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,
        0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,
        0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,
        0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,
        0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,
        0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff ],
      [ 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,
        0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,
        0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,
        0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,
        0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,
        0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,
        0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,
        0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,
        0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,
        0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,
        0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,
        0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,
        0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,
        0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,
        0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff ]
    ];

    [CrwDecoder::make_decoder(&first_tree[num]),
     CrwDecoder::make_decoder(&second_tree[num])]
  }

  fn get_bits_huff(pump: &mut BitPump, nbits: u32, huff: &[u16]) -> u32 {
    let c = pump.peek_bits(nbits) as usize;
    // Skip bits given by the high order bits of the huff table
    pump.consume_bits((huff[c] >> 8) as u32);
    // Return the lower order bits
    (huff[c] & 0xff) as u32
  }

  fn decode_compressed(&self, cam: &Camera, width: usize, height: usize) -> Result<Vec<u16>,String> {
    let mut out = vec![0 as u16; width*height];

    let dectable = fetch_tag!(self.ciff, CiffTag::DecoderTable).get_u32(0) as usize;
    if dectable > 2 {
      return Err(format!("CRW: Unknown decoder table {}", dectable).to_string())
    }

    let lowbits = !cam.find_hint("lowbits");
    let htables = CrwDecoder::init_huff_tables(dectable);
    let offset = 540 + (lowbits as usize)*height*width/4;
    let mut pump = BitPumpJPEG::new(&self.buffer[offset..]);

    let mut carry: i32 = 0;
    let mut base = [0 as i32;2];
    let mut pnum = 0;
    for row in (0..height).step(8) {
      let nblocks = cmp::min(8, height-row) * width >> 6;
      for block in 0..nblocks {
        let mut diffbuf = [0 as i32; 64];
        let mut i: usize = 0;
        while i < 64 {
          let tidx = (i > 0) as usize;
          let leaf = CrwDecoder::get_bits_huff(&mut pump, htables[tidx][0] as u32, &htables[tidx][1..]);
          if leaf == 0 && i != 0 { break; }
          if leaf == 0xff { i+= 1; continue; }
          i += (leaf >> 4) as usize;
          let len: u32 = leaf & 0x0f;
          if len == 0 { i+= 1; continue; }
          let mut diff: i32 = pump.get_bits(len) as i32;
          if (diff & (1 << (len-1))) == 0 {
            diff -= (1 << len) - 1;
          }
          if i < 64 {
            diffbuf[i] = diff;
          }
          i += 1;
        }
        diffbuf[0] += carry;
        carry = diffbuf[0];
        for i in 0..64 {
          if pnum % width == 0 {
            base[0] = 512;
            base[1] = 512;
          }
          pnum += 1;
          base[i & 1] += diffbuf[i];
          out[row*width + (block << 6) + i] = base[i & 1] as u16;
        }
      }

      // Add the uncompressed 2 low bits to the decoded 8 high bits
      if lowbits {
        let offset = 26 + row*width/4;
        let mut stream = ByteStream::new(&self.buffer[offset..], LITTLE_ENDIAN);
        let lines = cmp::min(height-row, 8); // Process 8 rows or however are left
        for i in 0..(width/4*lines) {
          let c = stream.get_u8() as u16;
          for r in 0..4 { // Fill in 4 pixels for each byte
            let mut val = out[row*width+i*4+r] << 2 | ((c >> r*2) & 0x0003);
            if width == 2672 && val < 512 {
              val += 2; // No idea why this is needed, probably some broken camera
            }
            out[row*width+i*4+r] = val;
          }
        }
      }
    }
    Ok(out)
  }
}
